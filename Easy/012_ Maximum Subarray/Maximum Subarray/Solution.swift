class Solution {
    func maxSubArray(_ nums: [Int]) -> Int {
        var sum = nums
        var maximum: Int = sum[0]    // 최대값
        
        for i in 1 ..< sum.count {
//            print("loop \(i)회차..")
//            print("sum배열: \(sum)")
//            print("sum[\(i)]: \(sum[i]) / sum[\(i-1)]: \(sum[i-1]) 비교")
            sum[i] = max(sum[i], sum[i-1] + sum[i])
            maximum = max(maximum, sum[i])  // (현재 값 + 이전부분합)과 (현재값)을 비교
//            print(sum)
//            print("최대값 : \(maximum)\n")
        }
        
        return maximum
    }
}

/*
 주어진 배열에서 연속된 값들의 합 중 최대값을 구하는 문제.
 이중 for문으로 인덱스 범위별로 모두 더해서 비교해도 되지만 O(n)으로 풀려면 Kadane's algorithm 을 사용해야합니다.
 최대 값을 구한 후 다음 값과 더해 다음 값이 더 크면 계속 더해주고 다음 값이 작으면 기존의 최대 값을 유지시켜 줍니다.
 우선 3회차 부분을 보게되면 이전 최대 값은 3이고, -10을 통해 계산하 경우 -10 + 3 = -7인 경우와 -10 + 3 + 4 = -3, -10 + 4 = -6인 부분이 존재 합니다.
 하지만 이 모든 값들은 연속해서 더했을 때 모두 음수가 나오며 sum[3] 값인 4보다 작습니다. 즉, 연속된 합을 구해도 혼자인 sum[3]보다 값이 작다는 소리입니다.
 6회차 분을 보면 -1을 만나 잠시 최대 값의 변화가 일어납니다. 떄문에 5회전과 6회전의 최대 값은 동일한 것을 알 수 있습니다.
 하지만 7회전에서 2를 더해 31보다 큰 32가 되었습니다. 이 경우도 6회전에서의 값인 30 + 2가 되었기 때문에 저렇게 된 것입니다.
 [1, 2, -10, 4, 12, 15, -1, 2, 3]

 */
